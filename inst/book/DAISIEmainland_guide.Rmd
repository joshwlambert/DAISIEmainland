---
title: "DAISIEmainland: Simulating and analysing macroevolution on island with a dynamic mainland"
author: "Joshua W. Lambert"
date: '`r Sys.Date()`'
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
description: "This is an introduction to the DAISIEmainland package."
bibliography: references.bib
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center"
)
```

# DAISIEmainland guide {-}

This guide is the long-form documentation of the `DAISIEmainland` R package.
It covers the basics from installation (Section \@ref(Installation)), to the
algorithm used to simulate the data (Section \@ref(Simulation-algorithm)), and
the visualisation of the island (Section \@ref(visualise-island)) and of the 
mainland (Section \@ref(visualise-mainland)). Then there is a demonstration of
the application of the `DAISIEmainland` package to the inference models in the 
`DAISIE` package (Section \@ref(Inference-performance)). Lastly, there is the
visualisation of the summary metrics that can be calculated from simulated data
(Section \@ref(Summary-metric-visualisation)). 

## Overview {-}

The `DAISIEmainland` package is used for simulating an island-mainland system.
It primary purpose is the simulation of phylogenetic data sets of island species
under a realistic model that incorporates evolutionary dynamics on the island and 
the mainland, from which the island species immigrate. This is in contrast to the
inference and simulation models included in the `DAISIE` package [@etienne_daisie_2022] which do not incorporate any changes in the mainland 
species through time. 

This novel model of mainland dynamics opens up the possibility of testing the 
robustness of the `DAISIE` likelihood models under various scenarios of mainland
dynamics. We also include the incomplete sampling of mainland species, either by
not sampling a known species or an undiscovered species which is present on the 
mainland but not known. These different sampling regimes are both possible in 
empirical studies and thus the sensitivity of model performance to these are 
important for future studies employing the `DAISIE` inference framework.

There is an appendix (Section \@ref(DAISIEmainland-data-standards)) which
contains details of the data structures used throughout the package, some of 
which are novel to this package and others are inherited from other packages 
(e.g. `DAISIE`). This appendix is meant for those looking to contribute and 
extend the `DAISIEmainland` package by explaining when certain data structures 
are used. If you are reading this guide to understand the general functionality
of the package this section can be ignored.

<!--chapter:end:index.Rmd-->

# Installation {#Installation}

You can install the released version of DAISIEmainland from github with:

``` r
# install.packages("remotes") # install remotes package if not installed
remotes::install_github("joshwlambert/DAISIEmainland")
```

The `DAISIEmainland` package has several dependencies (the entire list can be
found in the DESCRIPTION file). Most of these are on CRAN and can be installed with
`install.packages()`. However, the `DAISIE` [@etienne_daisie_2022] and `nLTT` packages [@janzen_nltt_2021] require more up-to-date version than available on
CRAN and need to be installed from github:

``` r
remotes::install_github("rsetienne/DAISIE")
remotes::install_github("thijsjanzen/nLTT")
```

Load the `DAISIEmainland` package with the `library()` function. This will also
load the package dependencies, specifically the `DAISIE` package which will be
used later on for parameter estimation by fitting maximum likelihood models.

```{r load package}
library(DAISIEmainland)
```

`DAISIEmainland` is currently not hosted on CRAN and thus cannot be installed
using `install.packages()`.

The package was developed using R version >= 4. Therefore, it is recommended to 
use an R version at least as recent as R 4.0.0. The package is tested using
continuous integration on the release version of R and the development version
of R. Therefore, any issues with running `DAISIEmainland` functions on older
versions of R will not be patched.

<!--chapter:end:installation.Rmd-->

# Simulation algorithm {#Simulation-algorithm}

The Doob-Gillespie algorithm is a stochastic exact solution that is used to
simulate continuous-time processes, with several applications 
in biological modelling. The Doob-Gillespie algorithm
can be used in evolutionary biology, for example to efficiently simulate a
birth-death process. The island-mainland simulation in the DAISIEmainland
package uses a two-part Doob-Gillespie simulation, one for the mainland
(`DAISIEmainland::sim_mainland`) and one for the island
(`DAISIEmainland::sim_island`).

## Mainland simulation {#Mainland-simulation}

The simulation of the island phylogenetic data takes two simulations. Firstly
the mainland, which is simulated under a Moran process, whereby every species extinction is immediately followed by a random species giving rise to two new species (speciation). Then the mainland phylogenetic data is fed into the 
island simulation (Section \@ref(Island-simulation)).

The mainland simulation uses a Doob-Gillespie algorithm to simulate the 
speciation and extinction of species under a Moran process to maintain a
constant number of species. Here the example shows mainland data being 
simulated for a time duration of one (million years), five initial mainland species, and a mainland extinction rate of one (per species per million years). 

```{r, simulate-mainland}
set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
mainland <- DAISIEmainland:::sim_mainland(
  total_time = 1,
  m = 5,
  mainland_ex = 1
)
```

The output is a list of five mainland clades called `multi_mainland_clade` (
see Section \@ref(multi-mainland-clade)).

```{r}
mainland
```

Specifically focusing on one of these mainland clades (see Section \@ref(mainland-clade)):

```{r}
mainland[[1]]
```

We can see that the information on this mainland clade include the ID of each
species (`spec_id`). The ID of the mainland ancestor from which that species
derived (`main_anc_id`). The type of species (`spec_type`) these can be `I`, 
`C`, or `E` for single lineage clade, cladogenetic species in a clade, or 
extinct species, respectively. All mainland species are initialised as 
`spec_id = I` but as the simulation progresses species become either 
part of a clade (`C`) or extinct (`E`). By keeping the extinct species we have
a full history of the mainland and not the so-called reconstructed history which
would only contain the living (extant) species. The `branch_code` provides the
evolutionary relationships of the species in the clade and allows the topology
of the clade to be constructed. The `branch_t` is the time when the species 
speciated from their common ancestor (in time after the start of the simulation
and not time before present). The `spec_origin_t` is the time the species 
originated and is often equal to the `branch_t`. The `spec_ex_t` is the time the species went extinct (again in time after the start of the simulation). Species
that do not go extinct are give a `spec_ex_t` equal to the total time of the 
simulation. 

Another example of what can happen on the mainland is the extinction of a 
singleton lineage before it underwent speciation. 

```{r}
mainland[[4]]
```

## Island simulation {#Island-simulation}

The island simulation runs after the mainland simulation and uses the mainland
data to determine which species can immigrate to the island through time. Doob-Gillespie algorithm is altered to accommodate the dynamic 
mainland pool. The time-steps are bounded to not jump over changes on the 
mainland to ensure the present state of the system (i.e. species on mainland)
is always up-to-date. The algorithm checks whether any changes have occurs on
the mainland since the last time step and if so the system is updated and the
returned to the time at which the mainland last changed. This is valid owing to
the Markov (memoryless) property of the Doob-Gillespie algorithm.

```{r}
set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
island_tbl <- DAISIEmainland:::sim_island(
  total_time = 1,
  island_pars = c(1, 1, 10, 1, 1),
  mainland_clade = mainland[[1]],
  mainland_sample_prob = 1,
  mainland_sample_type = "complete"
)
island_tbl
```

The island simulation outputs a `island_tbl` (see Section \@ref(island-tbl)). 
The `island_tbl` includes again the species ID (`spec_id`), mainland ancestor
ID (`main_anc_id`), species type (`spec_type`), branching code (`branch_code`), and branching time (`branch_t`). It also includes the time at which the species
colonised the island (`col_t`) and the reason a species is anagenetic (i.e.
endemic to the island without being in an island clade). The reasons for a 
species to be anagenetic are: the mainland population of the species goes 
extinct (`mainland_extinction`), the species undergoes anagenesis on the island
(`immig_parent`), or the species formed a clade but all other members of the 
clade went extinct before the present (`clade_extinct`). 

One major difference between the island and mainland data that are produced by
`sim_mainland()` and `sim_island()` is that the latter only has 
information from the reconstructed point of view. This means extinct species 
are removed from the data set and only species extant at the end of the 
simulation are included.

For both the island and mainland Doob-Gillespie algorithms time steps are
sampled from an exponential distribution with rate:
  
  $$X = \lambda e ^{-\lambda x}, \text{ where } \lambda = \sum_j r_j$$
  
where $r_j$ are the rates, for the mainland process this is just the rate of
mainland extinction ($\mu_M$), this is the only mainland parameter, whereas,
for the island algorithm $r_j$ are the rates of cladogenesis ($\lambda^c$),
island extinction ($\mu$), colonisation ($\gamma$), and anagenesis
($\lambda^a$). After the time step ($\Delta$ t) is sampled the event is sampled
from a dynamic discrete probability distribution, weighted by its rate
(propensity) relative to all other rates: 
  
  $$r_i / \sum_j r_j$$

The system is then updated for the algorithm repeats until the time step exceeds
the total time of the simulation. 

The function that encapsulates and runs both of these simulations is `sim_island_with_mainland()`. This function also includes the formatting of the data and the assignment of an endemicity status to each island colonist, which 
needed by the `DAISIE` inference model. The `DAISIEmainland` simulation outputs two data sets: (1) contains full information of all species colonisation times, and (2) an incomplete information data set which resembles what an empirist would have access to (see Section \@ref(daisie-mainland-data)). These two data sets allow for the quantification of error in
estimation when the empirists does not have access to all the data.

```{r, simulate-island-mainland}
set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
daisie_mainland_data <- sim_island_with_mainland(
  total_time = 1,
  m = 5,
  island_pars = c(1, 1, 10, 1, 1), 
  mainland_ex = 1,
  mainland_sample_prob = 1,
  mainland_sample_type = "unsampled",
  replicates = 1 
)
daisie_mainland_data
```

<!--chapter:end:simulation-algorithm.Rmd-->

# Simulation data visualisation {#simulation-data-visualisation}

In the previous section (Section \@ref(Simulation-algorithm)) it showed how the data is simulated. An important aspect is to see the data and `DAISIEmainland`
has a selection of plotting functions to plot the phylogenetic data of the 
mainland and the island. 

## Visualise mainland {#visualise-mainland}

We simulate the same mainland system as (Section \@ref(Mainland-simulation)) and then plot the all the mainland clades using `plot_mainland`.

```{r}
<<simulate-mainland>>
DAISIEmainland::plot_mainland(mainland)
```

The above plot shows the evolutionary history of each mainland species from the
start of the simulation, as five independent (i.e. no phylogenetic relatedness)
mainland species, to five extant species at the present. Each species is given
as unique species ID which are shown here as different coloured branches. The
colours can also be changed to represent the clade a species belongs to.

```{r}
DAISIEmainland::plot_mainland(mainland, branch_colour = "clade_id")
``` 

If there are many clades on the mainland it can be difficult to see when plotted
as an entire community. Instead individual mainland clades can be selected from
the data and plotted with `plot_mainland_clade`. Again the option of plotting 
the unique species ID or clade ID are available.

```{r, fig.align="left", fig.show="hold", out.width="45%"}
DAISIEmainland::plot_mainland_clade(
  mainland_clade = mainland[[1]], 
  branch_colour = "unique_species_id"
)
DAISIEmainland::plot_mainland_clade(
  mainland_clade = mainland[[1]], 
  branch_colour = "clade_id"
)
```

## Visualise island {#visualise-island}

The same set of plotting functionality exists for the island data. Here we 
simulate a range of possible outcomes for the island data and show how each
looks using the function `plot_daisie_data`.

1. An empty island

```{r, echo=FALSE, out.width="75%", out.height="50%"}
set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
daisie_mainland_data <- sim_island_with_mainland(
  total_time = 1,
  m = 5,
  island_pars = c(1, 1, 10, 0.2, 1), 
  mainland_ex = 1,
  mainland_sample_prob = 1,
  mainland_sample_type = "unsampled",
  replicates = 1 
)
plot_daisie_data(daisie_data = daisie_mainland_data$ideal_multi_daisie_data[[1]])
```

2. An island with a single non-endemic species

```{r, echo=FALSE, out.width="75%", out.height="50%"}
set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
daisie_mainland_data <- sim_island_with_mainland(
  total_time = 1,
  m = 5,
  island_pars = c(1, 1, 10, 0.5, 1), 
  mainland_ex = 1,
  mainland_sample_prob = 1,
  mainland_sample_type = "unsampled",
  replicates = 1 
)
plot_daisie_data(daisie_data = daisie_mainland_data$ideal_multi_daisie_data[[1]])
```

3. An island with a single endemic species

```{r, echo=FALSE, out.width="75%", out.height="50%"}
set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
daisie_mainland_data <- sim_island_with_mainland(
  total_time = 1,
  m = 5,
  island_pars = c(1, 1, 10, 0.5, 1), 
  mainland_ex = 2,
  mainland_sample_prob = 1,
  mainland_sample_type = "unsampled",
  replicates = 1 
)
plot_daisie_data(daisie_data = daisie_mainland_data$ideal_multi_daisie_data[[1]])
```

4. An island with a single non-endemic species which whose colonisation time
is older than the island age so it is considered an island-age colonisation
(i.e. it colonised at the island age because it could not have colonised 
before). This uncertainty in the timing of colonisation is then taken into
account when the data is input into the `DAISIE` likelihood model. 

```{r, echo=FALSE, out.width="75%", out.height="50%"}
set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
daisie_mainland_data <- sim_island_with_mainland(
  total_time = 1,
  m = 5,
  island_pars = c(1, 1, 10, 0.5, 1), 
  mainland_ex = 1,
  mainland_sample_prob = 0,
  mainland_sample_type = "unsampled",
  replicates = 1 
)
plot_daisie_data(
  daisie_data = daisie_mainland_data$empirical_multi_daisie_data[[1]]
)
```

5. An island with a single endemic species which whose colonisation time
is older than the island age so it is considered an island-age colonisation.
The uncertainty in colonisation time is handled in an equivalent way to the 
non-endemic island-age colonisation.

```{r, echo=FALSE, out.width="75%", out.height="50%"}
set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
daisie_mainland_data <- sim_island_with_mainland(
  total_time = 1,
  m = 5,
  island_pars = c(1, 1, 10, 0.5, 1), 
  mainland_ex = 2,
  mainland_sample_prob = 1,
  mainland_sample_type = "unsampled",
  replicates = 1 
)
plot_daisie_data(
  daisie_data = daisie_mainland_data$empirical_multi_daisie_data[[1]]
)
```

6. An island with an endemic clade whose colonisation time
is older than the island age so it is considered an island-age colonisation.
In `DAISIE` the colonisation time is assumed to have occurred between the
island age and the first branching time in the clade.

```{r, echo=FALSE, out.width="75%", out.height="50%"}
set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
daisie_mainland_data <- sim_island_with_mainland(
  total_time = 1,
  m = 5,
  island_pars = c(5, 1, 10, 0.2, 1), 
  mainland_ex = 2,
  mainland_sample_prob = 1,
  mainland_sample_type = "unsampled",
  replicates = 1 
)
plot_daisie_data(
  daisie_data = daisie_mainland_data$empirical_multi_daisie_data[[1]]
)
```

7. An island with an recolonisation of the same mainland species after it has 
colonised and speciated (either via cladogenesis or anagenesis on the island).
The colonists that are from the same ancestral mainland species but the island
species is now endemic are show by 'Colonist after anagenesis' and 'Colonist
after cladogenesis'.

```{r, echo=FALSE, out.width="75%", out.height="50%"}

set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
daisie_mainland_data <- sim_island_with_mainland(
  total_time = 1,
  m = 5,
  island_pars = c(2, 1, 10, 5, 2), 
  mainland_ex = 2,
  mainland_sample_prob = 1,
  mainland_sample_type = "unsampled",
  replicates = 1 
)
plot_daisie_data(
  daisie_data = daisie_mainland_data$ideal_multi_daisie_data[[1]]
)
```

All the above scenarios are of one of the `daisie_data` sets that are produced
from the `sim_island_with_mainland()` function which produces the `ideal_data`
and `empirical_data`. `plot_daisie_mainland_data` plots these two island data 
sets together.

```{r, echo=FALSE}
<<simulate-island-mainland>>

plot_daisie_mainland_data(
  daisie_mainland_data,
  replicate_index = 1
)
```

In the plot juxtaposing the `ideal_data` (top) and the `empirical_data` (bottom)
it is clear that the colonisation times differ for one of the island colonists.
In the `empirical_data` this colonist is an island-age colonist which is likely
due to the effects of mainland dynamics shifting the empiricist's perception of
the colonisation time.

<!--chapter:end:simulation-data-visualisation.Rmd-->

# Inference performance {#Inference-performance}

```{css, echo=FALSE}
pre {
  max-height: 1000px;
  overflow-y: auto;
}

pre[class] {
  max-height: 500px;
}
```

```{css, echo=FALSE}
.scroll-100 {
  max-height: 100px;
  overflow-y: auto;
  background-color: inherit;
}
```

One of the primary purposes of the `DAISIEmainland` package and specifically
why the data is formatted in the `DAISIE` format is to test the maximum 
likelihood inference models implemented in the `DAISIE` R package [@etienne_daisie_2022]. Therefore, in this section we explore how to conduct a
simple performance analysis of one of the `DAISIE` models. In this case we are
going to use the model with a single macroevolutionary regime on the island (
i.e. all island species are assumed to have the same rate of colonisation, 
speciation and extinction, as well as the same carrying capacity). This model
also assumes that the carrying capacity only operates between species within the
same island clade (termed clade-specific diversity-dependence), thus different
island colonists are supposed independent and not inhibiting the diversification
of each other.

As a small technical aside, this section uses `DAISIE` version 4.1.1. Re-running
this code on another system may produce different results, especially if a
different version of `DAISIE` is installed.

## Simulating data {#Simulating-data}

First, we simulate 100 replicates of island data. This will produce phylogenetic data for a 100 islands with the same parameter values. The reason multiple island
data sets are simulated is because the simualation algorithm is stochastic (Section \@ref(Simulation-algorithm)) and by iterating the simulation many times
it accounts for differences between data sets due to stochasticity. In an analysis more replicates (e.g. 1,000) can be run to account for the stochastic differences between replicates to more thoroughly sample the distribution of possible simulation outcomes.

Note: all the code below takes a substantial amount of time to run (on the order
of hours for 100 replicates). 

```{r, load-simulated-data, echo=FALSE}
daisie_mainland_data <- readRDS(
  file = system.file(
    "inst/book/data/daisie_mainland_data_100_rep.rds", 
    package = "DAISIEmainland")
)
```

```{r, run-simulation, eval=FALSE}
set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection")

replicates <- 100

daisie_mainland_data <- DAISIEmainland::sim_island_with_mainland(
  total_time = 1,
  m = 100,
  island_pars = c(0.5, 02.5, 50, 0.01, 0.5),
  mainland_ex = 1.0,
  mainland_sample_prob = 1,
  mainland_sample_type = "complete",
  replicates = replicates,
  verbose = FALSE
)
```

Now we have the simulated data, stored in `daisie_mainland_data` (see section \@ref(daisie-mainland-data)), which is a list object.
At the highest level of the list there are two lists: 
`daisie_mainland_data$ideal_multi_daisie_data` and
  `daisie_mainland_data$empirical_multi_daisie_data`. Each of these `multi_daisie_data` lists contains 100 elements, one for each simulation replicate. The `daisie_mainland_data$ideal_multi_daisie_data` and `daisie_mainland_data$empirical_multi_daisie_data` have the same structure.
The first element of each is the meta data, containing: `island_age` and the 
number of species `not_present` on the island that are on the mainland.

```{r Inspect data part 1}
daisie_mainland_data$ideal_multi_daisie_data[[1]][[1]]
daisie_mainland_data$empirical_multi_daisie_data[[1]][[1]]
```

Subsequent elements of the list are the island clades which are composed of:
`branching_times`, status of colonisation or `stac`, and number of
`missing_species`. The `branching_times` contains the age of the island, the
time of colonisation and any subsequent cladogenetic speciation times. The `stac`
is a numeric identifier of the endemicicity status and cladogenetic status (i.e. is the island colonist a singleton lineage or a clade). Lastly, the `missing_species` is the number of species known from an island clade but not
included in the `branching_times` vector as there is no phylogenetic information
on the timing of speciation for that species. In the `DAISIEmainland` simulation
we assume that we have phylogenetic information on all species on the island and thus `missing_species` is always set to zero.

```{r Inspect data part 2}
daisie_mainland_data$ideal_multi_daisie_data[[1]][[2]]
daisie_mainland_data$empirical_multi_daisie_data[[1]][[2]]
```

## Maximum likelihood inference {#Maximum-likelihood-inference}

To run a maximum likelihood DAISIE model, using the `DAISIE_ML_CS()` function, on each replicate we create objects to store the data in (`ideal_ml` and `empirical_ml`) and then loop over each replicate.

```{r, load ml data, echo=FALSE}
daisie_ml <- readRDS(
  file = system.file(
    "inst/book/data/daisie_ml_100_rep.rds", 
    package = "DAISIEmainland")
)

ideal_ml <- daisie_ml$ideal_ml
empirical_ml <- daisie_ml$empirical_ml
```

```{r Calculate parameter estimates, eval=FALSE}
ideal_ml <- vector("list", replicates)
empirical_ml <- vector("list", replicates)

for (i in seq_len(replicates)) {
  ideal_ml[[i]] <- DAISIE::DAISIE_ML_CS(
    datalist = daisie_mainland_data$ideal_multi_daisie_data[[i]],
    initparsopt = c(0.5, 02.5, 50, 0.01, 0.5),
    idparsopt = 1:5,
    parsfix = NULL,
    idparsfix = NULL,
    ddmodel = 11,
    methode = "odeint::runge_kutta_fehlberg78",
    optimmethod = "simplex",
    jitter = 1e-5)
  
  empirical_ml[[i]] <- DAISIE::DAISIE_ML_CS(
    datalist = daisie_mainland_data$empirical_multi_daisie_data[[i]],
    initparsopt = c(0.5, 02.5, 50, 0.01, 0.5),
    idparsopt = 1:5,
    parsfix = NULL,
    idparsfix = NULL,
    ddmodel = 11,
    methode = "odeint::runge_kutta_fehlberg78",
    optimmethod = "simplex",
    jitter = 1e-5)
}
```

The details of the maximum likelihood set up are not important, but a brief explainer: all model parameters are optimisied with the starting position in parameter space for optimisation, equal to the values used to simulate the data; the Runge-Kutta Fehlberg method to numerically solve the likelihood equations; and simplex is the optimisation algorithm to maximise the likelihood.

## Inference performance error metrics {#Inference-performance-error-metrics}

Now we have simulated 100 data sets, each with an *ideal* and *empirical* data
set, and fitted the DAISIE model to each, we need to quantify the error the DAISIE inference makes because it does not include mainland evolutionary dynamics. 

```{r, load error metrics, echo=FALSE}
error_metrics <- readRDS(
  file = system.file(
    "inst/book/data/error_metrics_100_rep.rds", 
    package = "DAISIEmainland")
)
```

The error metrics chosen to quantify this are:

1. The difference between the parameter estimates from *ideal* and *empirical* data, for cladogenesis (\$clado_ratio), extinction (\$ext_ratio), carrying capacity (\$k_ratio), colonisation (\$immig_ratio), and anagenesis (\$ana_ratio). This can be calculated as the *ideal* estimate minus *empirical* estimate,  or *ideal* estimate divided by the *empirical* estimate.

```{r Parameter differences, class.output="scroll-100"}
error_metrics$param_diffs
```

```{r Parameter ratios, class.output="scroll-100"}
error_metrics$param_ratios
```
  
2. Delta CTT ($\Delta$CTT) (difference in colonisations through time) between
the *ideal* and *empirical* data.

```{r Delta-CTT}
error_metrics$delta_ctt
```

3. Percentage of maximum island age colonisations (i.e. colonisations where
the most recent colonisation time extracted from the phylogenetic data is older
than the island) for the *ideal* and *empirical* data (only including colonisations that survive to the present). The ideal max age percentage is always zero as it is always known exactly when the species colonised the island, but is still calculated to check it is zero. The empirical max age percent can be any
percent [0, 100].

```{r Max-age-percentages}
error_metrics$max_age_percent
```

4. Percent of endemic species at the present. This includes counts of the 
number of endemic and non-endemic species in the *ideal* and *empirical* data, as 
well as the calculation of the percentage of endemic species in each data set.

```{r Endemic-percentages}
error_metrics$endemic_percent
```

Overall, all of these error metrics can be computed using `calc_error()` with the simulated data and the maximum likelihood estimates.

```{r Calculate error, eval=FALSE}
errors <- DAISIEmainland::calc_error(
  daisie_mainland_data = daisie_mainland_data,
  ideal_ml = ideal_ml,
  empirical_ml = empirical_ml
)
```

The code displayed in this chapter is a simplified version of the script used
to carry out the full inference performance analysis can be found at 
/scripts/run_analysis.R in the `DAISIEmainland` package. 

<!--chapter:end:inference-performance.Rmd-->

# Summary and error metrics visualisation {#Summary-error-metric-visualisation}

There is a range of plotting functions to visualise the summary metrics and 
error metrics (Section\@ref(Inference-performance-error-metrics)). 

## Simulation summary metrics

First we run the simulation. This is the same simulation as in the inference
performance section (Section \@ref(Simulating-data)).

```{r, echo=FALSE}
<<load-simulated-data>>
```

```{r, eval=FALSE}
<<run-simulation>>
```

The simulation summary metrics we can calculate for the *ideal* and *empirical* data are: 

1. number of species on the island at the end of the simulation
2. number of colonisation events to the island (that survived to the present) at the end of the simulation

```{r ideal-sim-num-spec}
ideal_sim_num_spec <- DAISIEmainland::calc_num_spec(
  multi_daisie_data = daisie_mainland_data$ideal_multi_daisie_data
)

ideal_sim_num_spec
```

```{r ideal-sim-num-col}
ideal_sim_num_col <- DAISIEmainland::calc_num_col(
  multi_daisie_data = daisie_mainland_data$ideal_multi_daisie_data
)

ideal_sim_num_col
```

```{r empirical-sim-num-spec}
empirical_sim_num_spec <- DAISIEmainland::calc_num_spec(
  multi_daisie_data = daisie_mainland_data$empirical_multi_daisie_data
)

empirical_sim_num_spec
```

```{r empirical-sim-num-col}
empirical_sim_num_col <- DAISIEmainland::calc_num_col(
  multi_daisie_data = daisie_mainland_data$empirical_multi_daisie_data
)

empirical_sim_num_col
```

We can plot the simulation summary metrics to view the mean, variance, maximum and 
minimum number of colonisations and number of species for the *ideal* and *empirical* 
data.

```{r, plot-simulation-summary-metrics}
plot_sim_metrics(
  analysis_results = analysis_results, 
  output_file_path = NULL
)
```

## Inference error metrics

The error metrics were run for a range of mainland extinction rates. Then the 
error metrics can be plotted across different rates to determine how the error
varies with faster or slower mainland evolutionary dynamics.

```{r, read-analysis-results}
analysis_results <- DAISIEmainland::read_analysis_results(
  data_folder_path = system.file(
    "/inst/book/data/param_sets/", 
    package = "DAISIEmainland"
  )
)
```

Plotting the $\Delta$CTT across mainland extinction rates between zero and two
(per species per million years). As explained in Section
\@ref(Inference-performance-error-metrics) this metric is a comparison between
the *ideal* and *empirical* data sets produced by the `DAISIEmainland` simulation.

```{r, plot-delta-ctt}
plot_ctt_boxplot(
  analysis_results = analysis_results, 
  output_file_path = NULL,
  parameter = "mainland_ex"
)
```

The percentage of endemics on the island at the end of the simulation and 
percentage of maximum age colonisation times can be plotted for different values
of mainland extinction. Each of the boxplots below contains 100 island replicates.
The left hand panel is for the data set with complete information (*ideal*) and
the right hand panel is for the data set with incomplete information (*empirical*).

```{r, plot-endemics}
plot_endemics(
  analysis_results = analysis_results, 
  output_file_path = NULL, 
  parameter = "mainland_ex"
) 
```

```{r, plot-max-age}
plot_max_age(
  analysis_results = analysis_results, 
  output_file_path = NULL, 
  parameter = "mainland_ex"
)
```

Error metrics can also be plotted across different values of mainland sampling
probability by setting the `parameter = "mainland_sample_prob` in the plotting
functions.

The plots shown in this chapter are not an exhaustive list available from the 
package. The script used to make the plots for the two manuscripts using this
package can be found at /scripts/joss_data_vis.R and /scripts/evolution_data_vis.R, 
respectively, in the `DAISIEmainland` package.

<!--chapter:end:summary-metrics-visualisation.Rmd-->

# References {#References}

<div id="refs"></div>

<!--chapter:end:references.Rmd-->

# (APPENDIX) Appendix {-} 

# DAISIEmainland data standards {#DAISIEmainland-data-standards}

## Reasoning

There are several data types used in this package. Some of them are novel to
this package and are not used elsewhere, others derive from other R packages.
This document provides a standard of how the data types are formatted and which
functions allow for checking the types.

To make sure the data types are correctly formatted there is a corresponding
`check_*` function for each.

## Data structure types

### `daisie_mainland_data` {#daisie-mainland-data}

A list of 2 elements, `$ideal_multi_daisie_data` and
`$empirical_multi_daisie_data`.
Each of these elements is in the format `multi_daisie_data` (see below). This
is the output of `DAISIEmainland::sim_island_with_mainland()`.

Function to check if it is a `daisie_mainland_data` is `DAISIEmainland::check_daisie_mainland_data()`

### `multi_daisie_data` {#multi-daisie-data}

A list of `daisie_data` elements (see below). This is the data structure when the
simulation is run for several replicates.

Function to check if it is a `multi_daisie_data` is
`DAISIEmainland::check_multi_daisie_data()`.

### `daisie_data` {#daisie-data}

* A list of n elements. The first element is a list containing the `island_age`
with a single numeric, and the number of species `not_present` on the island.
This first element in the `daisie_data` list can optionally include an
`stt_table`. The `stt_table` is a matrix with five columns and a variable number
of rows. Every subsequent element in the `daisie_data` list is data on an island
clade, containing: `branching_times`, `stac`, `missing_species`, and optionally
information on recolonisations `all_colonisations`. `branching_times` is a
numeric vector containing the island age, time of island colonisation, and an
subsequent branching times (all given in time before the present).

`daisie_data` is a single element of a `multi_daisie_data` list.

Function to check if it is a `daisie_data` is
`DAISIEmainland::check_daisie_data()`.

### `multi_mainland_clade` {#multi-mainland-clade}

A list of `mainland_clade` objects. This data type is output from `DAISIEmainland::sim_mainland()`.

Function to check if it is a `multi_mainland_clade` is
`DAISIEmainland::check_multi_mainland_clade()`.

### `mainland_clade` {#mainland-clade}

A data frame of seven columns and one or more rows. The column names are:
  `spec_id`, `main_anc_id`, `spec_type`, `branch_code`, `branch_t`,
`spec_origin_t`, `spec_ex_t`. A example of an `mainland_clade` can be created
using `DAISIEmainland::create_test_mainland_clade()`.

Function to check if it is a mainland_clade is
`DAISIEmainland::check_mainland_clade()`

### `island_tbl` {#island-tbl}

* A data frame of the island species output from `sim_island` and then converted
to the `daisie_data` format by `create_island`. This data type is output from
`DAISIEmainland::sim_island()`. A example of an `island_tbl` can be created
using `DAISIEmainland::create_test_island_tbl()`.

Function to check if it is a `island_tbl` is
`DAISIEmainland::check_island_tbl()`.

<!--chapter:end:data-standards.Rmd-->

