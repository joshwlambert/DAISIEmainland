[["index.html", "DAISIEmainland: Simulating and analysing macroevolution on island with a dynamic mainland DAISIEmainland guide Overview", " DAISIEmainland: Simulating and analysing macroevolution on island with a dynamic mainland Joshua W. Lambert 2022-04-15 DAISIEmainland guide This guide is the long-form documentation of the DAISIEmainland R package. It covers the basics from installation (Section 1), to the algorithm used to simulate the data (Section 2), and the visualisation of the island (Section 3.2) and of the mainland (Section 3.1). Then there is a demonstration of the application of the DAISIEmainland package to the inference models in the DAISIE package (Section 4). Lastly, there is the visualisation of the summary metrics that can be calculated from simulated data (Section 5). Overview The DAISIEmainland package is used for simulating an island-mainland system. It primary purpose is the simulation of phylogenetic data sets of island species under a realistic model that incorporates evolutionary dynamics on the island and the mainland, from which the island species immigrate. This is in contrast to the inference and simulation models included in the DAISIE package (Etienne et al. 2022) which do not incorporate any changes in the mainland species through time. This novel model of mainland dynamics opens up the possibility of testing the robustness of the DAISIE likelihood models under various scenarios of mainland dynamics. We also include the incomplete sampling of mainland species, either by not sampling a known species or an undiscovered species which is present on the mainland but not known. These different sampling regimes are both possible in empirical studies and thus the sensitivity of model performance to these are important for future studies employing the DAISIE inference framework. There is an appendix (Section A) which contains details of the data structures used throughout the package, some of which are novel to this package and others are inherited from other packages (e.g. DAISIE). This appendix is meant for those looking to contribute and extend the DAISIEmainland package by explaining when certain data structures are used. If you are reading this guide to understand the general functionality of the package this section can be ignored. "],["Installation.html", "1 Installation", " 1 Installation You can install the released version of DAISIEmainland from github with: # install.packages(&quot;remotes&quot;) # install remotes package if not installed remotes::install_github(&quot;joshwlambert/DAISIEmainland&quot;) The DAISIEmainland package has several dependencies (the entire list can be found in the DESCRIPTION file). Most of these are on CRAN and can be installed with install.packages(). However, the DAISIE (Etienne et al. 2022) and nLTT packages (Janzen and Bilderbeek 2021) require more up-to-date version than available on CRAN and need to be installed from github: remotes::install_github(&quot;rsetienne/DAISIE&quot;) remotes::install_github(&quot;thijsjanzen/nLTT&quot;) Load the DAISIEmainland package with the library() function. This will also load the package dependencies, specifically the DAISIE package which will be used later on for parameter estimation by fitting maximum likelihood models. library(DAISIEmainland) DAISIEmainland is currently not hosted on CRAN and thus cannot be installed using install.packages(). The package was developed using R version &gt;= 4. Therefore, it is recommended to use an R version at least as recent as R 4.0.0. The package is tested using continuous integration on the release version of R and the development version of R. Therefore, any issues with running DAISIEmainland functions on older versions of R will not be patched. "],["Simulation-algorithm.html", "2 Simulation algorithm 2.1 Mainland simulation 2.2 Island simulation", " 2 Simulation algorithm The Doob-Gillespie algorithm is a stochastic exact solution that is used to simulate continuous-time processes, with several applications in biological modelling. The Doob-Gillespie algorithm can be used in evolutionary biology, for example to efficiently simulate a birth-death process. The island-mainland simulation in the DAISIEmainland package uses a two-part Doob-Gillespie simulation, one for the mainland (DAISIEmainland::sim_mainland) and one for the island (DAISIEmainland::sim_island). 2.1 Mainland simulation The simulation of the island phylogenetic data takes two simulations. Firstly the mainland, which is simulated under a Moran process, whereby every species extinction is immediately followed by a random species giving rise to two new species (speciation). Then the mainland phylogenetic data is fed into the island simulation (Section 2.2). The mainland simulation uses a Doob-Gillespie algorithm to simulate the speciation and extinction of species under a Moran process to maintain a constant number of species. Here the example shows mainland data being simulated with for a time duration of one (million years), five initial mainland species, and a mainland extinction rate of one (per species per million years). set.seed( 1, kind = &quot;Mersenne-Twister&quot;, normal.kind = &quot;Inversion&quot;, sample.kind = &quot;Rejection&quot; ) mainland &lt;- DAISIEmainland:::sim_mainland( total_time = 1, m = 5, mainland_ex = 1 ) The output is a list of five mainland clades called multi_mainland_clade ( see Section A.2.4). mainland #&gt; [[1]] #&gt; spec_id main_anc_id spec_type branch_code branch_t spec_origin_t spec_ex_t #&gt; 1 1 1 E A NaN 0.0000000 0.7579891 #&gt; 2 10 1 E AA 0.7579891 0.7579891 0.9493026 #&gt; 3 11 1 C AB 0.7579891 0.7579891 1.0000000 #&gt; 4 12 1 C AAA 0.9493026 0.9493026 1.0000000 #&gt; 5 13 1 C AAB 0.9493026 0.9493026 1.0000000 #&gt; #&gt; [[2]] #&gt; spec_id main_anc_id spec_type branch_code branch_t spec_origin_t spec_ex_t #&gt; 1 2 2 E A NaN 0.0000000 0.1789954 #&gt; 2 8 2 C AA 0.1789954 0.1789954 1.0000000 #&gt; 3 9 2 E AB 0.1789954 0.1789954 0.7579891 #&gt; #&gt; [[3]] #&gt; spec_id main_anc_id spec_type branch_code branch_t spec_origin_t spec_ex_t #&gt; 1 3 3 E A NaN 0.0000000 0.1510364 #&gt; 2 6 3 E AA 0.1510364 0.1510364 0.9493026 #&gt; 3 7 3 C AB 0.1510364 0.1510364 1.0000000 #&gt; #&gt; [[4]] #&gt; spec_id main_anc_id spec_type branch_code branch_t spec_origin_t spec_ex_t #&gt; 1 4 4 E A NaN 0 0.1510364 #&gt; #&gt; [[5]] #&gt; spec_id main_anc_id spec_type branch_code branch_t spec_origin_t spec_ex_t #&gt; 1 5 5 E A NaN 0 0.1789954 Specifically focusing on one of these mainland clades (see Section A.2.5): mainland[[1]] #&gt; spec_id main_anc_id spec_type branch_code branch_t spec_origin_t spec_ex_t #&gt; 1 1 1 E A NaN 0.0000000 0.7579891 #&gt; 2 10 1 E AA 0.7579891 0.7579891 0.9493026 #&gt; 3 11 1 C AB 0.7579891 0.7579891 1.0000000 #&gt; 4 12 1 C AAA 0.9493026 0.9493026 1.0000000 #&gt; 5 13 1 C AAB 0.9493026 0.9493026 1.0000000 We can see that the information on this mainland clade include the ID of each species (spec_id). The ID of the mainland ancestor from which that species derived (main_anc_id). The type of species (spec_type) these can be I, C, or E for single lineage clade, cladogenetic species in a clade, or extinct species, respectively. All mainland species are initialised as spec_id = I but as the simulation progresses species become either part of a clade (C) or extinct (E). By keeping the extinct species we have a full history of the mainland and not the so-called reconstructed history which would only contain the living (extant) species. The branch_code provides the evolutionary relationships of the species in the clade and allows the topology of the clade to be constructed. The branch_t is the time when the species speciated from their common ancestor (in time after the start of the simulation and not time before present). The spec_origin_t is the time the species originated and is often equal to the branch_t. The spec_ex_t is the time the species went extinct (again in time after the start of the simulation). Species that do not go extinct are give a spec_ex_t equal to the total time of the simulation. Another example of what can happen on the mainland is the extinction of a singleton lineage before it underwent speciation. mainland[[4]] #&gt; spec_id main_anc_id spec_type branch_code branch_t spec_origin_t spec_ex_t #&gt; 1 4 4 E A NaN 0 0.1510364 2.2 Island simulation The island simulation runs after the mainland simulation and uses the mainland data to determine which species can immigrate to the island through time. Doob-Gillespie algorithm is altered to accommodate the dynamic mainland pool. The time-steps are bounded to not jump over changes on the mainland to ensure the present state of the system (i.e. species on mainland) is always up-to-date. The algorithm checks whether any changes have occurs on the mainland since the last time step and if so the system is updated and the returned to the time at which the mainland last changed. This is valid owing to the Markov (memoryless) property of the Doob-Gillespie algorithm. set.seed( 1, kind = &quot;Mersenne-Twister&quot;, normal.kind = &quot;Inversion&quot;, sample.kind = &quot;Rejection&quot; ) island_tbl &lt;- DAISIEmainland:::sim_island( total_time = 1, island_pars = c(1, 1, 10, 1, 1), mainland_clade = mainland[[1]], mainland_sample_prob = 1, mainland_sample_type = &quot;complete&quot; ) island_tbl #&gt; spec_id main_anc_id col_t spec_type branch_code branch_t ana_origin #&gt; 1 1 1 0.7551818 A &lt;NA&gt; NaN mainland_extinction #&gt; 2 10 10 0.8507697 A &lt;NA&gt; NaN mainland_extinction The island simulation outputs a island_tbl (see Section A.2.6). The island_tbl includes again the species ID (spec_id), mainland ancestor ID (main_anc_id), species type (spec_type), branching code (branch_code), and branching time (branch_t). It also includes the time at which the species colonised the island (col_t) and the reason a species is anagenetic (i.e. endemic to the island without being in an island clade). The reasons for a species to be anagenetic are: the mainland population of the species goes extinct (mainland_extinction), the species undergoes anagenesis on the island (immig_parent), or the species formed a clade but all other members of the clade went extinct before the present (clade_extinct). One major difference between the island and mainland data that are produced by sim_island_with_mainland() and sim_island() is that the latter only has information from the reconstructed point of view. This means extinct species are removed from the data set and only species extant at the end of the simulation are included. For both the island and mainland Doob-Gillespie algorithms time steps are sampled from an exponential distribution with rate: \\[X = \\lambda e ^{-\\lambda x}, \\text{ where } \\lambda = \\sum_j r_j\\] where \\(r_j\\) are the rates, for the mainland process this is just the rate of mainland extinction (\\(\\mu_M\\)), this is the only mainland parameter, whereas, for the island algorithm \\(r_j\\) are the rates of cladogenesis (\\(\\lambda^c\\)), island extinction (\\(\\mu\\)), colonisation (\\(\\gamma\\)), and anagenesis (\\(\\lambda^a\\)). After the time step (\\(\\Delta\\) t) is sampled the event is sampled from a dynamic discrete probability distribution, weighted by its rate (propensity) relative to all other rates: \\[r_i / \\sum_j r_j\\] The system is then updated for the algorithm repeats until the time step exceeds the total time of the simulation. The function that encapsulates and runs both of these simulations is sim_island_with_mainland(). This function also includes the formatting of the data and the assignment of an endemicity status to each island colonist, which needed by the DAISIE inference model. The DAISIEmainland simulation outputs two data sets: (1) contains full information of all species colonisation times, and (2) an incomplete information data set which resembles what an empirist would have access to (see Section A.2.1). These two data sets allow for the quantification of error in estimation when the empirists does not have access to all the data. set.seed( 1, kind = &quot;Mersenne-Twister&quot;, normal.kind = &quot;Inversion&quot;, sample.kind = &quot;Rejection&quot; ) daisie_mainland_data &lt;- sim_island_with_mainland( total_time = 1, m = 5, island_pars = c(1, 1, 10, 1, 1), mainland_ex = 1, mainland_sample_prob = 1, mainland_sample_type = &quot;unsampled&quot;, replicates = 1 ) daisie_mainland_data #&gt; $ideal_multi_daisie_data #&gt; $ideal_multi_daisie_data[[1]] #&gt; $ideal_multi_daisie_data[[1]][[1]] #&gt; $ideal_multi_daisie_data[[1]][[1]]$island_age #&gt; [1] 1 #&gt; #&gt; $ideal_multi_daisie_data[[1]][[1]]$not_present #&gt; [1] 3 #&gt; #&gt; #&gt; $ideal_multi_daisie_data[[1]][[2]] #&gt; $ideal_multi_daisie_data[[1]][[2]]$branching_times #&gt; [1] 1.0000000 0.1026008 #&gt; #&gt; $ideal_multi_daisie_data[[1]][[2]]$stac #&gt; [1] 2 #&gt; #&gt; $ideal_multi_daisie_data[[1]][[2]]$missing_species #&gt; [1] 0 #&gt; #&gt; #&gt; $ideal_multi_daisie_data[[1]][[3]] #&gt; $ideal_multi_daisie_data[[1]][[3]]$branching_times #&gt; [1] 1.0000000 0.9627315 #&gt; #&gt; $ideal_multi_daisie_data[[1]][[3]]$stac #&gt; [1] 2 #&gt; #&gt; $ideal_multi_daisie_data[[1]][[3]]$missing_species #&gt; [1] 0 #&gt; #&gt; #&gt; #&gt; #&gt; $empirical_multi_daisie_data #&gt; $empirical_multi_daisie_data[[1]] #&gt; $empirical_multi_daisie_data[[1]][[1]] #&gt; $empirical_multi_daisie_data[[1]][[1]]$island_age #&gt; [1] 1 #&gt; #&gt; $empirical_multi_daisie_data[[1]][[1]]$not_present #&gt; [1] 3 #&gt; #&gt; #&gt; $empirical_multi_daisie_data[[1]][[2]] #&gt; $empirical_multi_daisie_data[[1]][[2]]$branching_times #&gt; [1] 1.0000000 0.8489636 #&gt; #&gt; $empirical_multi_daisie_data[[1]][[2]]$stac #&gt; [1] 2 #&gt; #&gt; $empirical_multi_daisie_data[[1]][[2]]$missing_species #&gt; [1] 0 #&gt; #&gt; #&gt; $empirical_multi_daisie_data[[1]][[3]] #&gt; $empirical_multi_daisie_data[[1]][[3]]$branching_times #&gt; [1] 1.00000 0.99999 #&gt; #&gt; $empirical_multi_daisie_data[[1]][[3]]$stac #&gt; [1] 5 #&gt; #&gt; $empirical_multi_daisie_data[[1]][[3]]$missing_species #&gt; [1] 0 "],["simulation_data_visualisation.html", "3 Simulation data visualisation 3.1 Visualise mainland 3.2 Visualise island", " 3 Simulation data visualisation In the previous section (Section 2) it showed how the data is simulated. An important aspect is to see the data and DAISIEmainland has a selection of plotting functions to plot the phylogenetic data of the mainland and the island. 3.1 Visualise mainland We simulate the same mainland system as (Section 2.1) and then plot the all the mainland clades using plot_mainland. set.seed( 1, kind = &quot;Mersenne-Twister&quot;, normal.kind = &quot;Inversion&quot;, sample.kind = &quot;Rejection&quot; ) mainland &lt;- DAISIEmainland:::sim_mainland( total_time = 1, m = 5, mainland_ex = 1 ) DAISIEmainland::plot_mainland(mainland) The above plot shows the evolutionary history of each mainland species from the start of the simulation, as five independent (i.e. no phylogenetic relatedness) mainland species, to five extant species at the present. Each species is given as unique species ID which are shown here as different coloured branches. The colours can also be changed to represent the clade a species belongs to. DAISIEmainland::plot_mainland(mainland, branch_colour = &quot;clade_id&quot;) If there are many clades on the mainland it can be difficult to see when plotted as an entire community. Instead individual mainland clades can be selected from the data and plotted with plot_mainland_clade. Again the option of plotting the unique species ID or clade ID are available. DAISIEmainland::plot_mainland_clade( mainland_clade = mainland[[1]], branch_colour = &quot;unique_species_id&quot; ) DAISIEmainland::plot_mainland_clade( mainland_clade = mainland[[1]], branch_colour = &quot;clade_id&quot; ) 3.2 Visualise island The same set of plotting functionality exists for the island data. Here we simulate a range of possible outcomes for the island data and show how each looks using the function plot_daisie_data. An empty island An island with a single non-endemic species An island with a single endemic species An island with a single non-endemic species which whose colonisation time is older than the island age so it is considered an island-age colonisation (i.e. it colonised at the island age because it could not have colonised before). This uncertainty in the timing of colonisation is then taken into account when the data is input into the DAISIE likelihood model. An island with a single endemic species which whose colonisation time is older than the island age so it is considered an island-age colonisation. The uncertainty in colonisation time is handled in an equivalent way to the non-endemic island-age colonisation. An island with an endemic clade whose colonisation time is older than the island age so it is considered an island-age colonisation. In DAISIE the colonisation time is assumed to have occurred between the island age and the first branching time in the clade. An island with an recolonisation of the same mainland species after it has colonised and speciated (either via cladogenesis or anagenesis on the island). The colonists that are from the same ancestral mainland species but the island species is now endemic are show by Colonist after anagenesis and Colonist after cladogenesis. All the above scenarios are of one of the daisie_data sets that are produced from the sim_island_with_mainland() function which produces the ideal_data and empirical_data. plot_daisie_mainland_data plots these two island data sets together. #&gt; $ideal_multi_daisie_data #&gt; $ideal_multi_daisie_data[[1]] #&gt; $ideal_multi_daisie_data[[1]][[1]] #&gt; $ideal_multi_daisie_data[[1]][[1]]$island_age #&gt; [1] 1 #&gt; #&gt; $ideal_multi_daisie_data[[1]][[1]]$not_present #&gt; [1] 3 #&gt; #&gt; #&gt; $ideal_multi_daisie_data[[1]][[2]] #&gt; $ideal_multi_daisie_data[[1]][[2]]$branching_times #&gt; [1] 1.0000000 0.1026008 #&gt; #&gt; $ideal_multi_daisie_data[[1]][[2]]$stac #&gt; [1] 2 #&gt; #&gt; $ideal_multi_daisie_data[[1]][[2]]$missing_species #&gt; [1] 0 #&gt; #&gt; #&gt; $ideal_multi_daisie_data[[1]][[3]] #&gt; $ideal_multi_daisie_data[[1]][[3]]$branching_times #&gt; [1] 1.0000000 0.9627315 #&gt; #&gt; $ideal_multi_daisie_data[[1]][[3]]$stac #&gt; [1] 2 #&gt; #&gt; $ideal_multi_daisie_data[[1]][[3]]$missing_species #&gt; [1] 0 #&gt; #&gt; #&gt; #&gt; #&gt; $empirical_multi_daisie_data #&gt; $empirical_multi_daisie_data[[1]] #&gt; $empirical_multi_daisie_data[[1]][[1]] #&gt; $empirical_multi_daisie_data[[1]][[1]]$island_age #&gt; [1] 1 #&gt; #&gt; $empirical_multi_daisie_data[[1]][[1]]$not_present #&gt; [1] 3 #&gt; #&gt; #&gt; $empirical_multi_daisie_data[[1]][[2]] #&gt; $empirical_multi_daisie_data[[1]][[2]]$branching_times #&gt; [1] 1.0000000 0.8489636 #&gt; #&gt; $empirical_multi_daisie_data[[1]][[2]]$stac #&gt; [1] 2 #&gt; #&gt; $empirical_multi_daisie_data[[1]][[2]]$missing_species #&gt; [1] 0 #&gt; #&gt; #&gt; $empirical_multi_daisie_data[[1]][[3]] #&gt; $empirical_multi_daisie_data[[1]][[3]]$branching_times #&gt; [1] 1.00000 0.99999 #&gt; #&gt; $empirical_multi_daisie_data[[1]][[3]]$stac #&gt; [1] 5 #&gt; #&gt; $empirical_multi_daisie_data[[1]][[3]]$missing_species #&gt; [1] 0 In the plot juxtaposing the ideal_data (top) and the empirical_data (bottom) it is clear that the colonisation times differ for one of the island colonists. In the empirical_data this colonist is an island-age colonist which is likely due to the effects of mainland dynamics shifting the empiricists perception of the colonisation time. "],["Inference-performance.html", "4 Inference performance", " 4 Inference performance One of the primary purposes of the DAISIEmainland package and specifically why the data is formatted in the DAISIE format is to test the maximum likelihood inference models implemented in the DAISIE R package (Etienne et al. 2022). Therefore, in this section we explore how to conduct a simple performance analysis of one of the DAISIE models. In this case we are going to use the model with a single macroevolutionary regime on the island ( i.e. all island species are assumed to have the same rate of colonisation, speciation and extinction, as well as the same carrying capacity). This model also assumes that the carrying capacity only operates between species within the same island clade (termed clade-specific diversity-dependence), thus different island colonists are supposed independent and not inhibiting the diversification of each other. As a small technical aside, this section uses DAISIE version 4.1.1. Re-running this code on another system may produce different results, especially if a different version of DAISIE is installed. First, we simulate an island. This will produce phylogenetic data for a single island. In an analysis many more replicates (e.g. 1,000) would be required to account for the stochastic differences between replicates given the simulation is stochastic. set.seed( 1, kind = &quot;Mersenne-Twister&quot;, normal.kind = &quot;Inversion&quot;, sample.kind = &quot;Rejection&quot;) replicates &lt;- 1 daisie_mainland_data &lt;- DAISIEmainland::sim_island_with_mainland( total_time = 1, m = 100, island_pars = c(1, 1, 50, 0.1, 1), mainland_ex = 0.5, mainland_sample_prob = 1, mainland_sample_type = &quot;complete&quot;, replicates = replicates, verbose = FALSE ) Now we have the simulated data, stored in daisie_mainland_data (see section A.2.1), which is a list object. At the highest level of the list there are two lists (daisie_mainland_data$ideal_multi_daisie_data and daisie_mainland_data$empirical_multi_daisie_data). The first (daisie_mainland_data$ideal_multi_daisie_data) contains 1 element, if more replicates where run each element of daisie_mainland_data$ideal_multi_daisie_data is one replicate. The daisie_mainland_data$ideal_multi_daisie_data and daisie_mainland_data$empirical_multi_daisie_data have the same structure. The first element of each is the meta data, containing: island_age and the number of species not_present on the island that are on the mainland. daisie_mainland_data$ideal_multi_daisie_data[[1]][[1]] #&gt; $island_age #&gt; [1] 5 #&gt; #&gt; $not_present #&gt; [1] 91 daisie_mainland_data$empirical_multi_daisie_data[[1]][[1]] #&gt; $island_age #&gt; [1] 5 #&gt; #&gt; $not_present #&gt; [1] 91 Subsequent elements of the list are the island clades which are composed of: branching_times, status of colonisation or stac, and number of missing_species. daisie_mainland_data$ideal_multi_daisie_data[[1]][[2]] #&gt; $branching_times #&gt; [1] 5.0000000 0.1470333 #&gt; #&gt; $stac #&gt; [1] 4 #&gt; #&gt; $missing_species #&gt; [1] 0 daisie_mainland_data$empirical_multi_daisie_data[[1]][[2]] #&gt; $branching_times #&gt; [1] 5.0000000 0.1470333 #&gt; #&gt; $stac #&gt; [1] 4 #&gt; #&gt; $missing_species #&gt; [1] 0 To run a maximum likelihood DAISIE model on each replicate we create objects to store the data in (ideal_ml and empirical_ml) and then loop over each replicate. Here we lower the tolerance (tol argument) of the maximum likelihood optimisation to increase the speed of optimisation. However, when using the DAISIE_ML_CS() function the default values will provide accurate estimation to a sensible tolerance. ideal_ml &lt;- vector(&quot;list&quot;, replicates) empirical_ml &lt;- vector(&quot;list&quot;, replicates) for (i in seq_len(replicates)) { ideal_ml[[i]] &lt;- DAISIE::DAISIE_ML_CS( datalist = daisie_mainland_data$ideal_multi_daisie_data[[i]], initparsopt = c(1, 1, 50, 0.1, 1), idparsopt = 1:5, parsfix = NULL, idparsfix = NULL, ddmodel = 11, methode = &quot;odeint::runge_kutta_fehlberg78&quot;, optimmethod = &quot;simplex&quot;, tol = c(1e-01, 1e-02, 1e-04), jitter = 1e-5) empirical_ml[[i]] &lt;- DAISIE::DAISIE_ML_CS( datalist = daisie_mainland_data$empirical_multi_daisie_data[[i]], initparsopt = c(1, 1, 50, 0.1, 1), idparsopt = 1:5, parsfix = NULL, idparsfix = NULL, ddmodel = 11, methode = &quot;odeint::runge_kutta_fehlberg78&quot;, optimmethod = &quot;simplex&quot;, tol = c(1e-01, 1e-02, 1e-04), jitter = 1e-5) } To calculate the errors we can run calc_error() with the simulated data and the maximum likelihood estimates. errors &lt;- DAISIEmainland::calc_error( daisie_mainland_data = daisie_mainland_data, ideal_ml = ideal_ml, empirical_ml = empirical_ml) The errors are: Delta CTT (difference in colonisations through time) between the ideal and empirical data. errors$delta_ctt Percentage of maximum island age colonisations (i.e. colonisations where the most recent colonisation time extracted from the phylogenetic data is older than the island) for the ideal and empirical data (only included colonisations that survive to the present). The ideal max age percentage is always zero as it is always known exactly when the species colonised the island, but is still calculated to check it is zero. The empirical max age percent can be any percent [0, 100]. errors$max_age_percent Percent of endemic species at the present. This includes counts of the number of endemic and non-endemic species in the ideal and empirical data, as well as the calculation of the percentage of endemic species in each data set. errors$endemic_percent Parameter estimate ratios (i.e. ideal parameter estimates divided by its corresponding empirical parameter estimate), for cladogenesis ($clado_ratio), extinction ($ext_ratio), carrying capacity ($k_ratio), colonisation ($immig_ratio), and anagenesis ($ana_ratio). All parameters were estimated using the DAISIE maximum likelihood model (DAISIE::DAISIE_ML_CS()). These metrics show the difference in estimation of each parameter between [0, Inf]. errors$endemic_percent For the code used to run the analysis for Lambert et al. (2021) see the run_analysis.R script and for plotting see run_post_processing.R script. "],["Summary-metric-visualisation.html", "5 Summary metrics visualisation", " 5 Summary metrics visualisation island &lt;- DAISIEmainland::sim_island_with_mainland( total_time = 1, m = 100, island_pars = c(1, 1, 10, 0.1, 1), mainland_ex = 1, mainland_sample_prob = 1, mainland_sample_type = &quot;complete&quot;, replicates = 100, verbose = FALSE) We can now calculate the simulation metrics for the ideal and empirical islands. ideal_sim_num_spec &lt;- DAISIEmainland::calc_num_spec( multi_daisie_data = island$ideal_islands) ideal_sim_num_col &lt;- DAISIEmainland::calc_num_col( multi_daisie_data = island$ideal_islands) ideal_sim_metrics &lt;- list( ideal_sim_num_spec = ideal_sim_num_spec, ideal_sim_num_col = ideal_sim_num_col) empirical_sim_num_spec &lt;- DAISIEmainland::calc_num_spec( multi_daisie_data = island$empirical_islands) empirical_sim_num_col &lt;- DAISIEmainland::calc_num_col( multi_daisie_data = island$empirical_islands) empirical_sim_metrics &lt;- list( empirical_sim_num_spec = empirical_sim_num_spec, empirical_sim_num_col = empirical_sim_num_col) ideal_sim_metrics #&gt; $ideal_sim_num_spec #&gt; NULL #&gt; #&gt; $ideal_sim_num_col #&gt; NULL empirical_sim_metrics #&gt; $empirical_sim_num_spec #&gt; NULL #&gt; #&gt; $empirical_sim_num_col #&gt; NULL delta_ctt &lt;- DAISIEmainland:::calc_ctt(daisie_mainland_data = island) delta_ctt #&gt; [1] 0.0198423531 0.0375869616 0.0385190998 0.0498316678 0.0000000000 0.0451457506 #&gt; [7] 0.1254626724 0.0000000000 0.2010798782 0.0978902994 0.0710438797 0.0633101141 #&gt; [13] 0.0113853530 0.0515501136 0.0679692773 0.0370125785 0.0828112921 0.0167134516 #&gt; [19] 0.0470249456 0.0117385990 0.0672313536 0.1570890785 0.0110243998 0.0973086638 #&gt; [25] 0.0853679800 0.0667770322 0.0000000000 0.1327119186 0.0201382134 0.1063983257 #&gt; [31] 0.0238939323 0.0000000000 0.0454443284 0.0901270431 0.0039475818 0.0911970260 #&gt; [37] 0.0001188188 0.0525068261 0.0704606469 0.1401602391 0.1511830918 0.0646981843 #&gt; [43] 0.0333283613 0.1030739608 0.0625800553 0.0000000000 0.1328449419 0.0894403881 #&gt; [49] 0.0393074667 0.0904545768 0.0489380032 0.0817253614 0.0593455080 0.1133989452 #&gt; [55] 0.0386645018 0.0548612736 0.0807155739 0.0574742293 0.0100827302 0.0501421830 #&gt; [61] 0.0782963394 0.0039290389 0.0162945634 0.0295322364 0.0724539766 0.1054097922 #&gt; [67] 0.0270165478 0.1778420848 0.0481276449 0.0873319341 0.1308489726 0.1012175432 #&gt; [73] 0.0531205907 0.0000000000 0.0000000000 0.0798475232 0.0402341110 0.1009089173 #&gt; [79] 0.0522873239 0.0513682109 0.1438697852 0.0404612883 0.0000000000 0.3360946068 #&gt; [85] 0.0791335882 0.1690103789 0.0685559791 0.0618843536 0.0000000000 0.0972563932 #&gt; [91] 0.0550768066 0.1694114078 0.1087808985 0.0551484191 0.0000000000 0.0852573603 #&gt; [97] 0.0175991866 0.0000000000 0.0666978572 0.0000000000 max_age_percent &lt;- DAISIEmainland:::calc_max_age_percent(daisie_mainland_data = island) max_age_percent #&gt; $ideal_max_age #&gt; [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; [42] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; [83] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #&gt; #&gt; $empirical_max_age #&gt; [1] 12.500000 50.000000 7.692308 0.000000 0.000000 25.000000 16.666667 0.000000 #&gt; [9] 28.571429 16.666667 42.857143 12.500000 20.000000 23.529412 22.222222 14.285714 #&gt; [17] 20.000000 14.285714 14.285714 14.285714 33.333333 25.000000 0.000000 0.000000 #&gt; [25] 42.857143 11.111111 0.000000 50.000000 0.000000 14.285714 16.666667 0.000000 #&gt; [33] 22.222222 7.142857 0.000000 30.000000 33.333333 11.111111 33.333333 28.571429 #&gt; [41] 0.000000 18.181818 0.000000 27.272727 12.500000 0.000000 40.000000 0.000000 #&gt; [49] 0.000000 16.666667 14.285714 28.571429 25.000000 10.000000 0.000000 16.666667 #&gt; [57] 30.000000 11.111111 0.000000 42.857143 11.111111 20.000000 20.000000 14.285714 #&gt; [65] 14.285714 16.666667 0.000000 33.333333 16.666667 16.666667 40.000000 11.111111 #&gt; [73] 25.000000 0.000000 0.000000 16.666667 16.666667 0.000000 25.000000 25.000000 #&gt; [81] 20.000000 20.000000 0.000000 25.000000 37.500000 28.571429 16.666667 12.500000 #&gt; [89] 0.000000 36.363636 0.000000 40.000000 21.428571 12.500000 0.000000 16.666667 #&gt; [97] 16.666667 0.000000 20.000000 0.000000 endemic_percent &lt;- DAISIEmainland:::calc_endemic_percent(daisie_mainland_data = island) endemic_percent #&gt; $ideal_endemic_percent #&gt; [1] 70.00000 83.33333 86.66667 62.50000 54.54545 100.00000 62.50000 28.57143 #&gt; [9] 66.66667 75.00000 83.33333 66.66667 66.66667 71.42857 58.33333 37.50000 #&gt; [17] 80.00000 62.50000 90.00000 66.66667 71.42857 100.00000 92.30769 80.00000 #&gt; [25] 100.00000 83.33333 60.00000 80.00000 75.00000 80.00000 100.00000 80.00000 #&gt; [33] 100.00000 77.77778 42.85714 100.00000 66.66667 84.61538 85.71429 71.42857 #&gt; [41] 90.90909 93.75000 73.33333 75.00000 70.00000 66.66667 77.77778 72.72727 #&gt; [49] 60.00000 85.71429 72.72727 80.00000 83.33333 78.57143 87.50000 85.71429 #&gt; [57] 85.71429 100.00000 87.50000 92.30769 84.61538 83.33333 60.00000 62.50000 #&gt; [65] 75.00000 92.30769 83.33333 57.14286 92.30769 75.00000 75.00000 77.77778 #&gt; [73] 77.77778 62.50000 66.66667 83.33333 62.50000 72.72727 55.55556 100.00000 #&gt; [81] 100.00000 50.00000 20.00000 75.00000 87.50000 100.00000 88.88889 81.81818 #&gt; [89] 80.00000 81.25000 66.66667 75.00000 62.50000 80.00000 80.00000 85.71429 #&gt; [97] 80.00000 33.33333 76.92308 100.00000 #&gt; #&gt; $empirical_endemic_percent #&gt; [1] 70.00000 83.33333 86.66667 62.50000 54.54545 100.00000 62.50000 28.57143 #&gt; [9] 66.66667 75.00000 91.66667 66.66667 66.66667 71.42857 66.66667 37.50000 #&gt; [17] 80.00000 62.50000 90.00000 66.66667 71.42857 100.00000 92.30769 80.00000 #&gt; [25] 100.00000 83.33333 60.00000 80.00000 75.00000 80.00000 100.00000 80.00000 #&gt; [33] 100.00000 77.77778 42.85714 100.00000 66.66667 84.61538 85.71429 71.42857 #&gt; [41] 90.90909 93.75000 73.33333 75.00000 80.00000 66.66667 77.77778 72.72727 #&gt; [49] 60.00000 85.71429 72.72727 80.00000 83.33333 78.57143 87.50000 85.71429 #&gt; [57] 85.71429 100.00000 87.50000 92.30769 84.61538 83.33333 80.00000 62.50000 #&gt; [65] 75.00000 92.30769 83.33333 57.14286 92.30769 75.00000 75.00000 77.77778 #&gt; [73] 77.77778 62.50000 66.66667 83.33333 62.50000 72.72727 55.55556 100.00000 #&gt; [81] 100.00000 50.00000 20.00000 75.00000 87.50000 100.00000 88.88889 81.81818 #&gt; [89] 80.00000 81.25000 66.66667 87.50000 68.75000 80.00000 80.00000 85.71429 #&gt; [97] 90.00000 33.33333 84.61538 100.00000 #&gt; #&gt; $ideal_endemics #&gt; [1] 7 5 13 5 6 6 5 2 6 6 10 8 4 15 7 3 12 5 9 6 5 7 12 4 10 10 3 #&gt; [28] 4 6 8 8 8 19 14 3 14 2 11 6 5 10 15 11 12 7 4 7 8 3 6 8 8 5 11 #&gt; [55] 7 6 12 11 7 12 11 5 3 5 6 12 5 4 12 6 9 7 7 5 4 5 5 8 5 7 10 #&gt; [82] 3 2 3 7 10 8 9 4 13 2 6 10 8 4 6 8 2 10 7 #&gt; #&gt; $ideal_non_endemics #&gt; [1] 3 1 2 3 5 0 3 5 3 2 2 4 2 6 5 5 3 3 1 3 2 0 1 1 0 2 2 1 2 2 0 2 0 4 4 0 1 2 1 2 1 #&gt; [42] 1 4 4 3 2 2 3 2 1 3 2 1 3 1 1 2 0 1 1 2 1 2 3 2 1 1 3 1 2 3 2 2 3 2 1 3 3 4 0 0 3 #&gt; [83] 8 1 1 0 1 2 1 3 1 2 6 2 1 1 2 4 3 0 #&gt; #&gt; $empirical_endemics #&gt; [1] 7 5 13 5 6 6 5 2 6 6 11 8 4 15 8 3 12 5 9 6 5 7 12 4 10 10 3 #&gt; [28] 4 6 8 8 8 19 14 3 14 2 11 6 5 10 15 11 12 8 4 7 8 3 6 8 8 5 11 #&gt; [55] 7 6 12 11 7 12 11 5 4 5 6 12 5 4 12 6 9 7 7 5 4 5 5 8 5 7 10 #&gt; [82] 3 2 3 7 10 8 9 4 13 2 7 11 8 4 6 9 2 11 7 #&gt; #&gt; $empirical_non_endemics #&gt; [1] 3 1 2 3 5 0 3 5 3 2 1 4 2 6 4 5 3 3 1 3 2 0 1 1 0 2 2 1 2 2 0 2 0 4 4 0 1 2 1 2 1 #&gt; [42] 1 4 4 2 2 2 3 2 1 3 2 1 3 1 1 2 0 1 1 2 1 1 3 2 1 1 3 1 2 3 2 2 3 2 1 3 3 4 0 0 3 #&gt; [83] 8 1 1 0 1 2 1 3 1 1 5 2 1 1 1 4 2 0 "],["References.html", "6 References", " 6 References "],["DAISIEmainland-data-standards.html", "A DAISIEmainland data standards A.1 Reasoning A.2 Data structure types", " A DAISIEmainland data standards A.1 Reasoning There are several data types used in this package. Some of them are novel to this package and are not used elsewhere, others derive from other R packages. This document provides a standard of how the data types are formatted and which functions allow for checking the types. To make sure the data types are correctly formatted there is a corresponding check_* function for each. A.2 Data structure types A.2.1 daisie_mainland_data A list of 2 elements, $ideal_multi_daisie_data and $empirical_multi_daisie_data. Each of these elements is in the format multi_daisie_data (see below). This is the output of DAISIEmainland::sim_island_with_mainland(). Function to check if it is a daisie_mainland_data is DAISIEmainland::check_daisie_mainland_data() A.2.2 multi_daisie_data A list of daisie_data elements (see below). This is the data structure when the simulation is run for several replicates. Function to check if it is a multi_daisie_data is DAISIEmainland::check_multi_daisie_data(). A.2.3 daisie_data A list of n elements. The first element is a list containing the island_age with a single numeric, and the number of species not_present on the island. This first element in the daisie_data list can optionally include an stt_table. The stt_table is a matrix with five columns and a variable number of rows. Every subsequent element in the daisie_data list is data on an island clade, containing: branching_times, stac, missing_species, and optionally information on recolonisations all_colonisations. branching_times is a numeric vector containing the island age, time of island colonisation, and an subsequent branching times (all given in time before the present). daisie_data is a single element of a multi_daisie_data list. Function to check if it is a daisie_data is DAISIEmainland::check_daisie_data(). A.2.4 multi_mainland_clade A list of mainland_clade objects. This data type is output from DAISIEmainland::sim_mainland(). Function to check if it is a multi_mainland_clade is DAISIEmainland::check_multi_mainland_clade(). A.2.5 mainland_clade A data frame of seven columns and one or more rows. The column names are: spec_id, main_anc_id, spec_type, branch_code, branch_t, spec_origin_t, spec_ex_t. A example of an mainland_clade can be created using DAISIEmainland::create_test_mainland_clade(). Function to check if it is a mainland_clade is DAISIEmainland::check_mainland_clade() A.2.6 island_tbl A data frame of the island species output from sim_island and then converted to the daisie_data format by create_island. This data type is output from DAISIEmainland::sim_island(). A example of an island_tbl can be created using DAISIEmainland::create_test_island_tbl(). Function to check if it is a island_tbl is DAISIEmainland::check_island_tbl(). "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
