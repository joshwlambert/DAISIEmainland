---
title: "DAISIEmainland: Simulating and analysing macroevolution on island with a dynamic mainland"
author: "Joshua W. Lambert"
date: '`r Sys.Date()`'
documentclass: article
output:
bookdown::gitbook: default
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Overview

The `DAISIEmainland` package is used for simulating an island-mainland system.

# Installation

## Installation

You can install the released version of DAISIEmainland from github with:

``` r
remotes::install_github("joshwlambert/DAISIEmainland")
```

The `DAISIEmainland` package has several dependencies (the entire list can be
found in the DESCRIPTION file). Most of these are on CRAN and can be installed with
`install.packages()`. However, the DAISIE and nLTT packages require more
up-to-date version than available on CRAN and need to be installed from github:

``` r
remotes::install_github("rsetienne/DAISIE")
remotes::install_github("thijsjanzen/nLTT")
```

Load the DAISIEmainland package with the `library()` function. This will also
load the package dependencies, specifically the DAISIE package which will be
used later on for parameter estimation by fitting maximum likelihood models.

```{r load package}
library(DAISIEmainland)
```

# Simulation algorithm

The Doob-Gillespie algorithm is a stochastic exact solution that is used to
simulate continuous-time processes, with several applications 
in biological modelling. The Doob-Gillespie algorithm
can be used in evolutionary biology, for example to efficiently simulate a
birth-death process. The island-mainland simulation in the DAISIEmainland
package uses a two-part Doob-Gillespie simulation, one for the mainland
(`DAISIEmainland::sim_mainland`) and one for the island
(`DAISIEmainland::sim_island`).

Firstly the mainland, which is simulated under
a Moran process, whereby every species extinction is immediately 
followed by a random species giving rise to two new species (speciation).

```{r}
set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
mainland <- DAISIEmainland:::sim_mainland(total_time = 1,
                                          m = 5,
                                          mainland_ex = 1)
```

The output is a list of five mainland clades.

```{r}
mainland
```

The island Doob-Gillespie algorithm is altered to accommodate the dynamic 
mainland pool. The time-steps are bounded to not jump over changes on the 
mainland to ensure the present state of the system (i.e. species on mainland)
is always up-to-date. The algorithm checks whether any changes have occurs on
the mainland since the last time step and if so the system is updated and the
returned to the time at which the mainland last changed. This is valid owing to
the Markov (memoryless) property of the Doob-Gillespie algorithm.

```{r}
set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
island_tbl <- DAISIEmainland:::sim_island(
  total_time = 1,
  island_pars = c(1, 1, 10, 1, 1),
  mainland_clade = mainland[[1]],
  mainland_sample_prob = 1,
  mainland_sample_type = "complete"
)
```

For both the island and mainland Doob-Gillespie algorithms time steps are
sampled from an exponential distribution with rate:
  
  $$X = \lambda e ^{-\lambda x}, \text{ where } \lambda = \sum_j r_j$$
  
where $r_j$ are the rates, for the mainland process this is just the rate of
mainland extinction ($\mu_M$), this is the only mainland parameter, whereas,
for the island algorithm $r_j$ are the rates of cladogenesis ($\lambda^c$),
island extinction ($\mu$), colonisation ($\gamma$), and anagenesis
($\lambda^a$). After the time step ($\Delta$ t) is sampled the event is sampled
from a dynamic discrete probability distribution, weighted by its rate
(propensity) relative to all other rates: 
  
  $$r_i / \sum_j r_j$$

The system is then updated for the algorithm repeats until the time step exceeds
the total time of the simulation. Lastly, the data is formatted and the
endemicity of each island colonist is assigned which is used in the `DAISIE`
inference model. The `DAISIEmainland` simulation outputs two data sets: (1) 
contains full information of all species colonisation times, and (2) an 
incomplete information data set which resembles what an empirist would have
access to. These two data sets allow for the quantification of error in
estimation when the empirists does not have access to all the data.

# Simulation data visualisation

```{r}
# Let the RNG sequences be identical for R versions 3 and 4
set.seed(
  4,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection"
)
mainland <- DAISIEmainland::sim_mainland(
  total_time = 1, # total simulation time
  m = 4, # Number of mainland clades
  mainland_ex = 1) # mainland extinction rate

DAISIEmainland::plot_mainland(mainland)
``` 

# Inference performance

First, we simulate an island. This will produce phylogenetic data for a single
island. In an analysis many more replicates (e.g. 1,000) would be required to 
account for the stochastic differences between replicates given the simulation
is stochastic. 

```{r Run simulation}
set.seed(
  1,
  kind = "Mersenne-Twister",
  normal.kind = "Inversion",
  sample.kind = "Rejection")

replicates <- 1

daisie_mainland_data <- DAISIEmainland::sim_island_with_mainland(
  total_time = 1,
  m = 100,
  island_pars = c(1, 1, 50, 0.1, 1),
  mainland_ex = 0.5,
  mainland_sample_prob = 1,
  mainland_sample_type = "complete",
  replicates = replicates,
  verbose = FALSE
)
```

Now we have the data (stored in the island object), which is a list object.
At the highest level of the list there are two lists
(`daisie_mainland_data$ideal_multi_daisie_data` and
  `daisie_mainland_data$empirical_multi_daisie_data`). The first
(`daisie_mainland_data$ideal_multi_daisie_data`) contains 1
element, if more replicates where run each element of `daisie_mainland_data$ideal_multi_daisie_data` 
is one replicate. The `daisie_mainland_data$ideal_multi_daisie_data` and `daisie_mainland_data$empirical_multi_daisie_data` have the same structure.
The first element of each is the meta data, containing: `island_age` and the 
number of species `not_present` on the island that are on the mainland.

```{r Inspect data part 1}
daisie_mainland_data$ideal_multi_daisie_data[[1]][[1]]
daisie_mainland_data$empirical_multi_daisie_data[[1]][[1]]
```

Subsequent elements of the list are the island clades which are composed of:
`branching_times`, status of colonisation or `stac`, and number of
`missing_species`.

```{r Inspect data part 2}
daisie_mainland_data$ideal_multi_daisie_data[[1]][[2]]
daisie_mainland_data$empirical_multi_daisie_data[[1]][[2]]
```

To run a maximum likelihood DAISIE model on each replicate we create objects to
store the data in (`ideal_ml` and `empirical_ml`) and then loop over each
replicate. Here we lower the tolerance (`tol` argument) of the maximum
likelihood optimisation to increase the speed of optimisation. However, when 
using the `DAISIE_ML_CS()` function the default values will provide accurate
estimation to a sensible tolerance.

```{r Calculate parameter estimates}
ideal_ml <- vector("list", replicates)
empirical_ml <- vector("list", replicates)

for (i in seq_len(replicates)) {
  ideal_ml[[i]] <- DAISIE::DAISIE_ML_CS(
    datalist = daisie_mainland_data$ideal_multi_daisie_data[[i]],
    initparsopt = c(1, 1, 50, 0.1, 1),
    idparsopt = 1:5,
    parsfix = NULL,
    idparsfix = NULL,
    ddmodel = 11,
    methode = "odeint::runge_kutta_fehlberg78",
    optimmethod = "simplex",
    tol = c(1e-01, 1e-02, 1e-04),
    jitter = 1e-5)
  
  empirical_ml[[i]] <- DAISIE::DAISIE_ML_CS(
    datalist = daisie_mainland_data$empirical_multi_daisie_data[[i]],
    initparsopt = c(1, 1, 50, 0.1, 1),
    idparsopt = 1:5,
    parsfix = NULL,
    idparsfix = NULL,
    ddmodel = 11,
    methode = "odeint::runge_kutta_fehlberg78",
    optimmethod = "simplex",
    tol = c(1e-01, 1e-02, 1e-04),
    jitter = 1e-5)
}
```

To calculate the errors we can run `calc_error()` with the simulated data and 
the maximum likelihood estimates.

```{r Calculate error}
errors <- DAISIEmainland::calc_error(
  daisie_mainland_data = daisie_mainland_data,
  ideal_ml = ideal_ml,
  empirical_ml = empirical_ml)
```

The errors are: 
  
(1) Delta CTT (difference in colonisations through time) between
the ideal and empirical data.

```{r Display Delta CTT}
errors$delta_ctt
```

(2) Percentage of maximum island age colonisations (i.e. colonisations where
the most recent colonisation time extracted from the phylogenetic data is older
than the island) for the ideal and empirical data (only included colonisations 
that survive to the present). The ideal max age percentage is always zero as it
is always known exactly when the species colonised the island, but is still
calculated to check it is zero. The empirical max age percent can be any
percent [0, 100].

```{r Display Max age percentages}
errors$max_age_percent
```

(3) Percent of endemic species at the present. This includes counts of the 
number of endemic and non-endemic species in the ideal and empirical data, as 
well as the calculation of the percentage of endemic species in each data set.

```{r Display Endemic percentages}
errors$endemic_percent
```

(4) Parameter estimate ratios (i.e. ideal parameter estimates divided by its
corresponding empirical parameter estimate), for cladogenesis (\$clado_ratio),
extinction (\$ext_ratio), carrying capacity (\$k_ratio), colonisation
(\$immig_ratio), and anagenesis (\$ana_ratio). All parameters were estimated
using the DAISIE maximum likelihood model (`DAISIE::DAISIE_ML_CS()`). These
metrics show the difference in estimation of each parameter between [0, Inf].

```{r Display Parameter estimate ratios}
errors$endemic_percent
```

For the code used to run the analysis for Lambert et al. (2021) see the
`run_analysis.R` script and for plotting see `run_post_processing.R` script.

# Summary metrics visualisation

```{r}
island <- DAISIEmainland::sim_island_with_mainland(
  total_time = 1,
  m = 100,
  island_pars = c(1, 1, 10, 0.1, 1),
  mainland_ex = 1,
  mainland_sample_prob = 1,
  mainland_sample_type = "complete",
  replicates = 100,
  verbose = FALSE)
```

We can now calculate the simulation metrics for the ideal and empirical islands.

```{r Calculate simulation metrics}
ideal_sim_num_spec <- DAISIEmainland::calc_num_spec(
  multi_daisie_data = island$ideal_islands)
ideal_sim_num_col <- DAISIEmainland::calc_num_col(
  multi_daisie_data = island$ideal_islands)
ideal_sim_metrics <- list(
  ideal_sim_num_spec = ideal_sim_num_spec,
  ideal_sim_num_col = ideal_sim_num_col)
empirical_sim_num_spec <- DAISIEmainland::calc_num_spec(
  multi_daisie_data = island$empirical_islands)
empirical_sim_num_col <- DAISIEmainland::calc_num_col(
  multi_daisie_data = island$empirical_islands)
empirical_sim_metrics <- list(
  empirical_sim_num_spec = empirical_sim_num_spec,
  empirical_sim_num_col = empirical_sim_num_col)

ideal_sim_metrics
empirical_sim_metrics
```

```{r}
delta_ctt <- DAISIEmainland:::calc_ctt(daisie_mainland_data = island)
delta_ctt
```

```{r}
max_age_percent <- DAISIEmainland:::calc_max_age_percent(daisie_mainland_data = island)
max_age_percent
```

```{r}
endemic_percent <- DAISIEmainland:::calc_endemic_percent(daisie_mainland_data = island)
endemic_percent
```

# References


